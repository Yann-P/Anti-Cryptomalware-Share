import signal
import time
import os
import sys
import copy

from xcs_response import XCSResponse
from xcs_attack import XCSAttack
from xcs_samba_log import XCSSambaLog
import xcs_share_helper

class XCSMonitor:

	def __init__(self, msg, args, config, samba_log_parser_path):
		self.msg 			= msg
		self._args 			= args
		self._config 			= config
		self._attacks 			= {}
		self._alarm_interval 		= int(config.get('MONITOR_FREQUENCY'))
		self._share_path 		= config.get('SHARE_PATH')
		self._response_threads 		= [] # do we need that??

		if not xcs_share_helper.check_if_root():
			raise XCSMonitorException("xcs-monitor needs root. please restart with sudo.")			

		self._check_git_status_is_clean()
		self._setup_alarm()
		self._setup_usr1()		
		
		self._samba_watcher		= XCSSambaLog(samba_log_parser_path, config.get('SAMBA_LOG_PATH')) # may need to rename that class

		print("Now monitoring changes in %s" % self._share_path)

		
	def _check_git_status_is_clean(self):
		if xcs_share_helper.nb_files_changed(self._share_path) != 0:
			if int(self._config.get('AUTO_ROLLBACK')) == 1:
				print("Auto-rollback : Performing rollback")
				res = xcs_share_helper.rollback(self._share_path)
				if res is False:
					raise XCSMonitorException("rollback failed.")
			else:
				raise XCSMonitorException("you must revert the changes before starting the monitor.\nuse the rollback command.")
		return True

	def _invoke_response(self, attack):
		thread = XCSResponse(attack, self._config, self._args.verbose)
		self._response_threads.append(thread)
		thread.start()
 
	def _setup_alarm(self):
		signal.signal(signal.SIGALRM, self._alarm_handler)
		signal.alarm(self._alarm_interval)

	def _interrupt_handler(self, signum, frame):
		pass

	def _alarm_handler(self, signum, frame):
		report  = self._samba_watcher.get_report()

		for username, damage in report.items():

			ip_addresses = xcs_share_helper.get_ip_addresses(username)
			
			if len(ip_addresses) == 0:
				raise XCSMonitorException("IP address(es) for %s could not be retreived." % username)
				

			for ip in ip_addresses:
				hostname = xcs_share_helper.get_hostname(ip)
				primary_key = (username, ip, hostname)

				if primary_key in self._attacks:
					ongoing_attack = self._attacks[primary_key]
					print("existing attack #%d" % ongoing_attack.id, end="")

					if ongoing_attack.get_damage() != damage: # we don't trigger response if nothing new!
						print(", updated to " + str(damage))
						ongoing_attack.set_damage(copy.copy(damage))
						self._invoke_response(ongoing_attack)
					else:
						print(", nothing new :)")

				else:
					attack = XCSAttack(username, ip, hostname, copy.copy(damage))
					self._attacks[primary_key] = attack
					print("new attack %s created with %s" % (str(attack), str(damage)))
					self._invoke_response(attack)

		signal.alarm(self._alarm_interval)

	def _setup_usr1(self):
		signal.signal(signal.SIGUSR1, self._usr1_handler)

	def _usr1_handler(self, signum, frame):
		print("Report is")
		print(self._samba_watcher.get_report())
		print("Attacks are")
		print(self._attacks)

	def __exit__(self):
		print("EXITED")

class XCSMonitorException(Exception):
	pass
