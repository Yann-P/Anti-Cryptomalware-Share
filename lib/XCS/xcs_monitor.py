import os
import signal
import logging

from xcs_response import XCSResponse
from xcs_attack import XCSAttack, XCSAttackStatus
from xcs_samba_log_watcher import XCSSambaLogWatcher
from helpers import xcs_share_helper
from response_actions.xcs_admin_notifier import XCSAdminNotifier
from response_actions.xcs_victim_notifier import XCSVictimNotifier
from response_actions.xcs_file_logger import XCSFileLogger
from response_actions.xcs_syslogger import XCSSysLogger

class XCSMonitor:

	def __init__(self, args, config, samba_log_parser_path):
		self._args = args
		self.config = config
		self._active_attacks = {}
		self._alarm_interval = config.getval('MONITOR_FREQUENCY')
		self._share_path = config.getval('SHARE_PATH')
		self._response_threads = []

		if not os.geteuid() == 0:
			raise XCSMonitorException("xcs-monitor needs root. please restart with sudo.")			

		self._enforce_clean_git_repository()
		self._setup_alarm()
		self._setup_usr1()
		
		self._samba_watcher	= XCSSambaLogWatcher(
			parser_path = samba_log_parser_path,
			log_to_watch_path = config.getval('SAMBA_LOG_PATH'),
			files_to_ignore = config.getval('IGNORE_BASENAME_LIST')
		)

		logging.info("Now monitoring changes in %s" % self._share_path)

		
	def _enforce_clean_git_repository(self):
		try:
			git_status = xcs_share_helper.nb_files_changed(self._share_path)
		except OSError as e:
			raise XCSMonitorException("Error checking the share git repository: " + str(e))

		if git_status != 0:
			if self.config.getval('AUTO_ROLLBACK'):
				logging.info("Auto-rollback : Performing rollback")
				if not xcs_share_helper.rollback(self._share_path):
					raise XCSMonitorException("startup rollback failed.")
			else:
				raise XCSMonitorException("you must revert the changes before starting the monitor.\nuse the rollback command.")

	def _invoke_response(self, attack, attack_status):
		response = XCSResponse(attack, attack_status, self.config.getval('NOTIFY_INTERVAL'))

		if self.config.getval('SYSLOG_ENABLED'): 			response.add_action(XCSSysLogger(self.config))
		if self.config.getval('FILE_LOGS_ENABLED'): 		response.add_action(XCSFileLogger(self.config))
		if self.config.getval('NOTIFY_ADMIN_ENABLED'): 		response.add_action(XCSAdminNotifier(self.config))
		if self.config.getval('NOTIFY_VICTIM_ENABLED'): 	response.add_action(XCSVictimNotifier(self.config))

		response.start()

		self._response_threads.append(response)

	def _nb_active_attacks_for(self, username):
		res = 0
		for primary_key, attack in self._active_attacks.items():
			if primary_key[0] == username:
				res += 1
		return res

	def _register_attack(self, key, attack):
		self._active_attacks[key] = attack

	def _unregister_attack(self, key):
		del self._active_attacks[key]


	def _check_share(self):
		report  = self._samba_watcher.get_report()
		for username, damage in list(report.items()):

			ip_addresses = xcs_share_helper.get_ip_addresses(username)
			
			if len(ip_addresses) == 0:
				ip_addresses.append("?") # that happens when the client is not connected anymore!

			for ip in ip_addresses:
				hostname = xcs_share_helper.get_hostname(ip)
				key = (username, ip, hostname)

				if key in self._active_attacks:
					attack = self._active_attacks[key]
					self._feed_attack(attack, damage)

					if attack.seconds_since_last_damage_update() > self.config.getval('NOTIFY_INTERVAL'):
						logging.debug("~attack is over #%s " % attack.id)
						if self._nb_active_attacks_for(username) <= 1:
							self._invoke_response(attack, XCSAttackStatus.OVER)
							self._unregister_attack(key)
							self._samba_watcher.clear(username)

							if len(self._active_attacks) is 0 and self.config.getval('AUTO_ROLLBACK'):
								xcs_share_helper.rollback(self._share_path, False)

						else: logging.debug("others attacks active for user.")

				else:
					attack = XCSAttack(username, ip, hostname, damage)
					logging.debug("~new attack #%s " % attack.id)
					self._register_attack(key, attack)
					self._invoke_response(attack, XCSAttackStatus.NEW)



		

	def _feed_attack(self, attack, damage):
		logging.debug("~existing attack #%s " % attack.id)
		
		if attack.get_damage() != damage: # we don't trigger response if nothing new!
			logging.debug("  updated to " + str(damage))
			attack.update_damage(damage)
			self._invoke_response(attack, XCSAttackStatus.UPDATED)


	# Kernel signals

	def _setup_alarm(self):
		signal.signal(signal.SIGALRM, self._alarm_handler)
		signal.alarm(self._alarm_interval)

	def _alarm_handler(self, signum, frame):
		self._check_share()
		signal.alarm(self._alarm_interval)

	def _setup_usr1(self):
		signal.signal(signal.SIGUSR1, self._usr1_handler)

	def _usr1_handler(self, signum, frame):
		logging.info("Report is")
		logging.info(self._samba_watcher.get_report())
		logging.info("Attacks are")
		logging.info(self._active_attacks)


class XCSMonitorException(Exception):
	pass
