import signal
import time
import os
import sys
import copy

from xcs_response import XCSResponse
from xcs_attack import XCSAttack
from xcs_samba_log import XCSSambaLog
import xcs_share_helper

class XCSMonitor:

	def __init__(self, msg, args, config, samba_log_parser_path):
		self.msg 			= msg
		self._args 			= args
		self.config 			= config
		self._attacks 			= {}
		self._alarm_interval 		= config.getval('MONITOR_FREQUENCY')
		self._share_path 		= config.getval('SHARE_PATH')
		self._response_threads 		= [] # do we need that??

		if not xcs_share_helper.check_if_root():
			raise XCSMonitorException("xcs-monitor needs root. please restart with sudo.")			

		self._check_git_status_is_clean()
		self._setup_alarm()
		self._setup_usr1()		
		
		self._samba_watcher		= XCSSambaLog(samba_log_parser_path, config.getval('SAMBA_LOG_PATH')) # may need to rename that class

		print("Now monitoring changes in %s" % self._share_path)

		
	def _check_git_status_is_clean(self):
		if xcs_share_helper.nb_files_changed(self._share_path) != 0:
			if self.config.getval('AUTO_ROLLBACK') == 1:
				print("Auto-rollback : Performing rollback")
				res = xcs_share_helper.rollback(self._share_path)
				if res is False:
					raise XCSMonitorException("rollback failed.")
			else:
				raise XCSMonitorException("you must revert the changes before starting the monitor.\nuse the rollback command.")
		return True

	def _invoke_response(self, attack):
		thread = XCSResponse(attack, self.config, self._args.verbose)
		self._response_threads.append(thread)
		thread.start()
 
	def _setup_alarm(self):
		signal.signal(signal.SIGALRM, self._alarm_handler)
		signal.alarm(self._alarm_interval)


	def _alarm_handler(self, signum, frame):
		self._check_share()
		signal.alarm(self._alarm_interval)

	def _check_share(self):
		
		report  = self._samba_watcher.get_report()
		for username, damage in list(report.items()):

			ip_addresses = xcs_share_helper.get_ip_addresses(username)
			
			if len(ip_addresses) == 0:
				#raise XCSMonitorException("IP address(es) for %s could not be retreived." % username)
				ip_addresses.append("?") # that happens when the client is not connected anymore!

			for ip in ip_addresses:
				hostname = xcs_share_helper.get_hostname(ip)
				primary_key = (username, ip, hostname)

				if primary_key in self._attacks:
					alive = self._feed_attack(self._attacks[primary_key], damage)
					if not alive:
						print("  attack considered over.")
						del self._attacks[primary_key]
						self._samba_watcher.clear(username)
				else:
					attack = XCSAttack(username, ip, hostname, damage)
					self._attacks[primary_key] = attack
					print("new attack %s" % str(attack))
					self._invoke_response(attack)
		

	def _feed_attack(self, attack, damage):
		print("existing attack #%d " % attack.id)
		
		if attack.get_damage() != damage: # we don't trigger response if nothing new!
			print("  updated to " + str(damage))
			attack.update_damage(damage)
			self._invoke_response(attack)
	
		return attack.seconds_since_last_damage_update() <= 10

	def _setup_usr1(self):
		signal.signal(signal.SIGUSR1, self._usr1_handler)

	def _usr1_handler(self, signum, frame):
		print("Report is")
		print(self._samba_watcher.get_report())
		print("Attacks are")
		print(self._attacks)


class XCSMonitorException(Exception):
	pass
