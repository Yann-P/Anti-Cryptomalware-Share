import os
import signal
import logging

from xcs_response import XCSResponse
from xcs_attack import XCSAttack, XCSAttackStatus
from xcs_samba_log_watcher import XCSSambaLogWatcher
from helpers import xcs_share_helper
from response_actions.xcs_admin_notifier import XCSAdminNotifier
from response_actions.xcs_victim_notifier import XCSVictimNotifier
from response_actions.xcs_file_logger import XCSFileLogger
from response_actions.xcs_syslogger import XCSSysLogger

class XCSMonitor:

	def __init__(self, args, config):
		self._args = args
		self.config = config
		self._attacks = {}
		self._alarm_interval = config.getval('MONITOR_FREQUENCY')
		self._share_path = config.getval('SHARE_PATH')
		self._response_threads = []

		if not os.geteuid() == 0:
			raise XCSMonitorException("xcs-monitor needs root. please restart with sudo.")			

		self._enforce_clean_git_repository()
		self._setup_alarm()
		self._setup_usr1()
		
		self._samba_watcher	= XCSSambaLogWatcher(
			log_to_watch_path = config.getval('SAMBA_LOG_PATH'),
			files_to_ignore = config.getval('IGNORE_BASENAME_LIST')
		)

		logging.info("Now monitoring changes in %s" % self._share_path)

		
	def _enforce_clean_git_repository(self):
		try:
			git_status = xcs_share_helper.nb_files_changed(self._share_path)
		except OSError as e:
			raise XCSMonitorException("Error checking the share git repository: " + str(e))

		if git_status != 0:
			if self.config.getval('AUTO_ROLLBACK'):
				logging.info("Auto-rollback : Performing rollback")
				if not xcs_share_helper.rollback(self._share_path):
					raise XCSMonitorException("startup rollback failed.")
			else:
				raise XCSMonitorException("you must revert the changes before starting the monitor.\nuse the rollback command.")

	def _invoke_response(self, attack):
		response = XCSResponse(attack, self.config.getval('NOTIFY_INTERVAL'))

		if self.config.getval('SYSLOG_ENABLED'): 			response.add_action(XCSSysLogger(self.config))
		if self.config.getval('FILE_LOGS_ENABLED'): 		response.add_action(XCSFileLogger(self.config))
		if self.config.getval('NOTIFY_ADMIN_ENABLED'): 		response.add_action(XCSAdminNotifier(self.config))
		if self.config.getval('NOTIFY_VICTIM_ENABLED'): 	response.add_action(XCSVictimNotifier(self.config))

		response.start()

		self._response_threads.append(response)

	def _get_active_attacks_for(self, user):
		return [attack for key, attack in list(self._attacks.items()) if attack.is_active()]

	def _register_attack(self, key, attack):
		self._attacks[key] = attack

	def _unregister_attack(self, key):
		del self._attacks[key]


	def _get_connections_for_user(self, username):
		
		keys = [] # a key is a tuple of (username, ip, hostname)

		ip_addresses = xcs_share_helper.get_ip_addresses(username)
		
		if not len(ip_addresses):
			ip_addresses.append(None) # that happens when the client is not connected anymore!

		for ip in ip_addresses:
		
			hostname = xcs_share_helper.get_hostname(ip) if ip else None
			key = (username, ip, hostname)
			keys.append(key)

		return keys
		

	def _check_share(self):
		report  = self._samba_watcher.get_report()
		
		for username, damage in list(report.items()):
			
			keys = self._get_connections_for_user(username)

			for key in keys:
				self._process_report(username, damage, key)
	
	# todo split up this horrible thing into smaller pieces
	def _process_report(self, username, damage, key):
		(username, ip, hostname) = key
		
		active_attack_by_this_user = self._get_active_attacks_for(username)
				
		if len(active_attack_by_this_user) > 0:
			if ip is None: # the client disconnected before we have a chance to identify
				ip = active_attack_by_this_user[0].ip
				hostname = active_attack_by_this_user[0].hostname
			elif hostname is None: # TODO the following block has to be tested
				hostname = active_attack_by_this_user[0].hostname
			key = (username, ip, hostname)

		logging.debug(str(key))

		if key in self._attacks:
			attack = self._attacks[key]
			logging.debug("~existing attack #%s " % attack.id)
			

			if attack.get_damage() != damage: # we don't trigger response if nothing new!

				logging.debug("attack #%s updated to %s" % (attack.id, repr(damage)))
				attack.set_status(XCSAttackStatus.UPDATED)
				attack.update_damage(damage)
				self._invoke_response(attack)
					
			if attack.seconds_since_last_damage_update() > self.config.getval('NOTIFY_INTERVAL'):
						
				logging.debug("~mark attack as over #%s " % attack.id)
				attack.set_status(XCSAttackStatus.OVER)
							
				if len(self._get_active_attacks_for(username)) is 0:
					logging.debug("~attack is over #%s" % attack.id)
					self._invoke_response(attack)
					self._unregister_attack(key)
					self._samba_watcher.clear(username)

					if len(self._attacks) is 0 and self.config.getval('AUTO_ROLLBACK'):
						xcs_share_helper.rollback(self._share_path, False)

				else: logging.debug("others attacks active for user.")

		else:

			attack = XCSAttack(username, ip, hostname, damage)
			logging.debug("~new attack #%s " % attack.id)
			self._register_attack(key, attack)
			self._invoke_response(attack)
					

	# Kernel signals

	def _setup_alarm(self):
		signal.signal(signal.SIGALRM, self._alarm_handler)
		signal.alarm(self._alarm_interval)

	def _alarm_handler(self, signum, frame):
		self._check_share()
		signal.alarm(self._alarm_interval)

	def _setup_usr1(self):
		signal.signal(signal.SIGUSR1, self._usr1_handler)

	def _usr1_handler(self, signum, frame):
		logging.info("Report is")
		logging.info(self._samba_watcher.get_report())
		logging.info("Attacks are")
		logging.info(self._attacks)


class XCSMonitorException(Exception):
	pass
