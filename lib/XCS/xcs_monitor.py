# Copyright 2016 Technical University of Denmark
# Yann Pellegrini, Hugo Maxwell Connery
# Licensed under GPLv3

import os
import signal
import logging

from xcs_response import XCSResponse
from xcs_attack import XCSAttack, XCSAttackStatus
from xcs_samba_log_watcher import XCSSambaLogWatcher
from helpers import xcs_share_helper
from response_actions.xcs_admin_notifier import XCSAdminNotifier
from response_actions.xcs_victim_notifier import XCSVictimNotifier
from response_actions.xcs_file_logger import XCSFileLogger
from response_actions.xcs_syslogger import XCSSysLogger

class XCSMonitor:

	def __init__(self, args, config):
		self._args = args
		self.config = config
		self._attacks = {}
		self._alarm_interval = config.getval('MONITOR_FREQUENCY')
		self._share_path = config.getval('SHARE_PATH')
		self._response_threads = []

		self._enforce_run_as_root()
		self._enforce_clean_git_repository()

		self._samba_watcher	= XCSSambaLogWatcher(
			log_to_watch_path = config.getval('SAMBA_LOG_PATH'),
			files_to_ignore = config.getval('IGNORE_BASENAME_LIST')
		)

		signal.signal(signal.SIGALRM, self._alarm_handler)
		signal.signal(signal.SIGUSR1, self._usr1_handler)
		signal.alarm(self._alarm_interval)

		logging.info("Now monitoring changes in %s" % self._share_path)


	def _alarm_handler(self, signum, frame):
		self._check_share()
		signal.alarm(self._alarm_interval)


	def _usr1_handler(self, signum, frame):
		logging.info("Report is")
		logging.info(self._samba_watcher.get_report())
		logging.info("Attacks are")
		logging.info(self._attacks)


	def _check_share(self):
		""" called asynchronously by a SIGALRM
			retrieves username to damage object from the samba watcher, then retreives connection info (ip, hostname)
			before processing the attack.
		"""
		report = self._samba_watcher.get_report()
		for username, damage in list(report.items()):
			for ip, hostname in self._get_connections_for_user(username):
				self._process_report(username, ip, hostname, damage)

	def _process_report(self, username, ip, hostname, damage):
		if not ip:
			ip, hostname = self._get_previous_attack_connection(username)

		key = (username, ip, hostname)
		if key in self._attacks:
			self._process_existing_attack(self._attacks[key], damage)
		else:
			self._create_attack(username, ip, hostname, damage)


	def _process_existing_attack(self, attack, damage):
		logging.debug('existing attack #%s ' % attack.id)

		if attack.get_damage() != damage:
			self._update_attack(attack, damage)
		else:
			attack.set_status(XCSAttackStatus.NOTHING_NEW)

		if attack.seconds_since_last_damage_update() > self.config.getval('NOTIFY_INTERVAL'):
			logging.debug("mark attack as over #%s " % attack.id)
			attack.set_status(XCSAttackStatus.OVER)

			if len(self._get_active_attacks_for(attack.username)) is 0:
				self._remove_attack(attack)
				if len(self._attacks) is 0 and self.config.getval('AUTO_ROLLBACK'):
					xcs_share_helper.rollback(self._share_path, False)
			else:
				logging.debug("others attacks active for user.")


	def _create_attack(self, username, ip, hostname, damage):
		attack = XCSAttack(username, ip, hostname, damage)
		logging.debug("new attack #%s " % attack.id)
		self._register_attack(attack)
		self._invoke_response(attack)


	def _update_attack(self, attack, damage):
		logging.debug("attack #%s updated to %s" % (attack.id, repr(damage)))
		attack.set_status(XCSAttackStatus.UPDATED)
		attack.update_damage(damage)
		self._invoke_response(attack)


	def _remove_attack(self, attack):
		logging.debug("~attack is over #%s" % attack.id)
		self._invoke_response(attack)
		self._unregister_attack(attack.key)
		self._samba_watcher.clear(attack.username)


	def _invoke_response(self, attack):
		response = XCSResponse(attack, self.config.getval('NOTIFY_INTERVAL'))

		if self.config.getval('SYSLOG_ENABLED'): 			response.add_action(XCSSysLogger(self.config))
		if self.config.getval('FILE_LOGS_ENABLED'): 		response.add_action(XCSFileLogger(self.config))
		if self.config.getval('NOTIFY_ADMIN_ENABLED'): 		response.add_action(XCSAdminNotifier(self.config))
		if self.config.getval('NOTIFY_VICTIM_ENABLED'): 	response.add_action(XCSVictimNotifier(self.config))

		response.start()

		self._response_threads.append(response)


	def _get_previous_attack_connection(self, username):
		""" this function is used when we can't get the connection details for a username.
			:return: the first non-None connection details for this user in its active attack
		"""
		for active_attack in self._get_active_attacks_for(username):
			if active_attack.ip:
				return (active_attack.ip, active_attack.hostname)

		return (None, None)


	def _get_connections_for_user(self, username):
		""" :return: list of active samba connections for username. a connection is a tuple of (ip, hostname)
		"""

		connections = []
		ip_addresses = xcs_share_helper.get_ip_addresses(username)
		if not len(ip_addresses):
			ip_addresses.append(None)  # that happens when the client is not connected anymore!
		for ip in ip_addresses:
			hostname = xcs_share_helper.get_hostname(ip) if ip else None
			connections.append((ip, hostname))
		return connections

	#def _clean_old_attacks_for(self, username):


	def _get_active_attacks_for(self, user):
		return [attack for key, attack in list(self._attacks.items()) if attack.is_active()]


	def _register_attack(self, attack):
		self._attacks[attack.key] = attack


	def _unregister_attack(self, key):
		del self._attacks[key]


	def _enforce_clean_git_repository(self):
		"""
		Checks if the git repository the monitor is running on is clean.
		:raises: XCSMonitorException
		"""
		try:
			git_status = xcs_share_helper.nb_files_changed(self._share_path)
		except OSError as e:
			raise XCSMonitorException("Error checking the share git repository: " + str(e))

		if git_status != 0:
			if self.config.getval('AUTO_ROLLBACK'):
				logging.info("Auto-rollback : Performing rollback")
				if not xcs_share_helper.rollback(self._share_path):
					raise XCSMonitorException("startup rollback failed.")
			else:
				raise XCSMonitorException(
					"you must revert the changes before starting the monitor.\nuse the rollback command.")


	def _enforce_run_as_root(self):
		"""
		Checks if the script was ran as root as smbstatus and nbmlookup needs it
		:raises: XCSMonitorException
		"""
		if not os.geteuid() == 0:
			raise XCSMonitorException("xcs-monitor needs root. please restart with sudo.")



class XCSMonitorException(Exception):
	pass
