#!/usr/bin/env python3.4
import signal
import subprocess
from threading import Thread
import sys
import os
from xcs_damage import XCSDamage, XCSDamageType

class SambaLog(object):
	
	def __init__(self, config):
		self._config = config
		self._info_by_filename = {} 	# { path1 => [(user1, op1), ..., (usern, opn)] }
		self._users_to_damage = {} 	# { user => XCSDamage }
		
		signal.signal(signal.SIGINT, self._interrupt_handler)

		self._watcher = subprocess.Popen("./test_emulate_samba.sh",
			#shell=True,
			stdout=subprocess.PIPE)
		
		self._thread = Thread(target=self._watch)#, args=(self,))		
		self._thread.start()

	#@staticmethod
	def _watch(self):
		
		for line in iter(self._watcher.stdout.readline, b''):
			line = line.decode('utf-8').split()
			print(line)
			self._add(username=line[0], damage_type=line[1], path=line[2])
		
	def _add(self, username, damage_type, path):
		print(damage_type)
		damage_type = XCSDamageType(damage_type)

		if not path in self._info_by_filename:
			self._info_by_filename[path] = []
		self._info_by_filename[path].append((username, damage_type))
		
		if username in self._users_to_damage:
			existing_damage = self._users_to_damage[username]
			print("username %s has already done damage before" % username)
			print(str(existing_damage))
			existing_damage += damage_type
		else:
			self._users_to_damage[username] = XCSDamage() + damage_type

		print("username " + username + " has now damage=" + str(self._users_to_damage[username]))

	def _who(self, path):
		return self._path_to_users[path]

	def report(self):
		return self._users_to_damage[username]
		
	def clear(self, username):
		del self.users_to_damage[username]
		for path, user in self._info_by_filename:
			if user == username:
				del self._info_by_filename[path]

	def _interrupt_handler(self, signum, frame):
		self._watcher.terminate()
		self._thread.join()

class SambaLogException(Exception):
	pass

# tests
if __name__ == '__main__':
	sl = SambaLog(None)
