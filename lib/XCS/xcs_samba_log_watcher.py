# Copyright 2016 Technical University of Denmark
# Yann Pellegrini, Hugo Maxwell Connery
# Licensed under GPLv3

import signal
import threading
import os
import logging
import re
from xcs_damage import XCSDamage, XCSDamageType

class XCSSambaLogWatcher(object):
	
	def __init__(self, log_to_watch_path, files_to_ignore):
		self._users_to_damage = {} 	# { user => XCSDamage }
		self._log_to_watch_path = log_to_watch_path
		self._thread_must_terminate = threading.Event()
		self._thread = threading.Thread(target=self._watch)
		self._basenames_to_ignore = files_to_ignore.split(' ')
		signal.signal(signal.SIGINT, self._interrupt_handler)

		if not os.path.exists(self._log_to_watch_path):
			raise XCSSambaLogWatcherException("The samba log is not accessible at %s" % self._log_to_watch_path)

		self._thread.start()

	# thread that parses the samba log in real time.
	def _watch(self):
		
		file = open(self._log_to_watch_path, 'r')
		
		# Here we want to emulate a tail -f. find the size of the file and move to the end
		st_results = os.stat(self._log_to_watch_path)
		st_size = st_results[6]
		file.seek(st_size)

		while not self._thread_must_terminate.is_set():
			where = file.tell()
			line = file.readline()
			if not line:
				pass
			else:
				regex = "^\s+(.+) opened file (.+) read=(Yes|No) write=(Yes|No) \(numopen=(\d+)\)$"
				res = re.match(regex, line)
				if res is not None:
					username = res.group(1)
					path = res.group(2)
					read = res.group(3)
					write = res.group(4)

					damage_type = self._get_file_operation_by_readwrite(read, write)


					if damage_type is not None: # we don't care if no write has happened.
						self._add(username, damage_type, path)
		
		logging.debug("XCSSambaLogWatcher: end of parser stream.")
	

	def _get_file_operation_by_readwrite(self, read, write):
		match = {
			('Yes', 'Yes'): 	XCSDamageType.MODIFICATION, # modif
			('No', 'Yes'): 		XCSDamageType.CREATION, # creation
			('No', 'No'): 		XCSDamageType.DELETION, # deletion
			('Yes', 'No'): 		None # read, don't care.
		}
		return match[(read, write)]

	def _add(self, username, damage_type, path):
		logging.debug(username + " " + damage_type.value + " " + path)

		if os.path.basename(path).lower() in self._basenames_to_ignore:
			return
		
		if username in self._users_to_damage:
			existing_damage = self._users_to_damage[username]
			existing_damage.add_damage_type(damage_type, 1)
		else:
			damage = XCSDamage()
			damage.add_damage_type(damage_type, 1)
			self._users_to_damage[username] = damage


	def get_report(self):
		return self._users_to_damage
		
	def clear(self, username):
		del self._users_to_damage[username]

	def _interrupt_handler(self, signum, frame):
		self._thread_must_terminate.set()
		self._thread.join()

class XCSSambaLogWatcherException(Exception):
	pass

