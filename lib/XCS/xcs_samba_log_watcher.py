#!/usr/bin/env python3.4
import signal
import subprocess
import threading
import sys
import os
import time
import logging
import re
from xcs_damage import XCSDamage, XCSDamageType

class XCSSambaLogWatcher(object):
	
	def __init__(self, log_to_watch_path, files_to_ignore):
		self._users_to_damage = {} 	# { user => XCSDamage }
		self._log_to_watch_path = log_to_watch_path
		self._thread_must_terminate = threading.Event()
		self._thread = threading.Thread(target=self._watch)
		self._thread.start()
		self._basenames_to_ignore = files_to_ignore.split(' ')
		signal.signal(signal.SIGINT, self._interrupt_handler)

	# thread that parses the samba log in real time.
	def _watch(self):
		
		file = open(self._log_to_watch_path, 'r')
		
		# Here we want to emulate a tail -f. find the size of the file and move to the end
		st_results = os.stat(self._log_to_watch_path)
		st_size = st_results[6]
		file.seek(st_size)

		while not self._thread_must_terminate.is_set():
			where = file.tell()
			line = file.readline()
			if not line:
				pass
			else:
				regex = "^\s+(.+) opened file (.+) read=(Yes|No) write=(Yes|No) \(numopen=(\d+)\)$"
				res = re.match(regex, line)
				if res is not None:
					username = res.group(1)
					damage_type = self._get_file_operation_by_readwrite(res.group(3), res.group(4))
					path = res.group(2)

					if damage_type is not None: # we don't care if no write has happened.
						self._add(username, damage_type, path)
		
		logging.debug("XCSSambaLogWatcher: end of parser stream.")
	

	def _get_file_operation_by_readwrite(self, read, write):
		match = {
			('Yes', 'Yes'): 'm', # modif
			('No', 'Yes'): 'c', # creation
			('No', 'No'): 'd', # deletion
			('Yes', 'No'): None # read
		}
		return match[(read, write)]

	def _add(self, username, damage_type, path):
		logging.debug(username + " " + damage_type + " " + path)

		if os.path.basename(path).lower() in self._basenames_to_ignore:
			return

		damage_type = XCSDamageType(damage_type)
		
		if username in self._users_to_damage:
			existing_damage = self._users_to_damage[username]
			existing_damage += damage_type
		else:
			self._users_to_damage[username] = XCSDamage() + damage_type


	def get_report(self):
		return self._users_to_damage
		
	def clear(self, username):
		del self._users_to_damage[username]

	def _interrupt_handler(self, signum, frame):
		self._thread_must_terminate.set()
		self._thread.join()

class XCSSambaLogWatcherException(Exception):
	pass

