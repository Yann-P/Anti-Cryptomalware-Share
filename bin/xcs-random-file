#!/usr/bin/env python

import sys, os, argparse, random

# General: prog name, lib dir, default config etc.
prog_name = os.path.basename(sys.argv[0])
prog_dir = os.path.dirname(sys.argv[0])
lib_dir = os.path.join(prog_dir, '..', 'lib', 'XCS')
sys.path.append(lib_dir)

# Defaults and statics
word_file = '/usr/share/dict/words'
default_num_words = 3
default_min_size_kb = 1
default_max_size_kb = 200
rand_block_dev = "/dev/random"


# Get our library
from xcs_msg import XCSMsg
# For the message object
msg = XCSMsg(prog_name)

#
# Parse command-line args.
#
def cmdline():
	prog_desc = """
	Make file name composed of random words with an optional
	"nice to encrypt" extension.  Optionally, also create the \
	file in a specified directory with min/max size.
	"""
	arg_parser = argparse.ArgumentParser(prog=prog_name, 
		description=prog_desc)

	arg_parser.add_argument('-n', '--num-words', 
		default=default_num_words, type=int,
		help="Number of random words to use in the file name")
	arg_parser.add_argument('-d', '--directory', 
		default=None,
		help="Actually create the file in the specified directory")
	arg_parser.add_argument('-m', '--min-size-kb', 
		default=default_min_size_kb, type=int,
		help="Mininum size of the file to be created (only with -d)")
	arg_parser.add_argument('-M', '--max-size-kb', 
		default=default_min_size_kb, type=int,
		help="Maximum size of the file to be created (only with -d)")
	arg_parser.add_argument('-b', '--bare', action="store_true",
		default=False, 
		help="Bare file name (no extension)")
	arg_parser.add_argument('-v', '--verbose', 
		default=False, 
		help="Debug mode")
	args = arg_parser.parse_args()
	if ( args.directory is not None and not os.path.isdir(args.directory) ):
		msg.err("Directory arg '" + args.directory + "' does not exist")
		exit(1)
	if ( args.min_size_kb > args.max_size_kb ):
		msg.err("Size error: min must be <= max")
	return args

#
# The job; make the file name of random words from the dict plus
# and attractive extension for cypto-malware
#
def make_file_name(args, dict_max_words):
	# File extensions that malware wants to encrypt
	extn = [ 'docx', 'xlsx', 'pdf', 'png', 'jpg', 'doc', 'xls', 
	'avi', 'mp3', 'mp4', 'txt']
	retval = 'nothing'
	#
	# We form the line numbers and then use sed of the form
	#   sed -n '<num>p;<num>p;...' to print out only those line numbers
	#
	sed_args = []
	i = 0
	while ( i < args.num_words ):
		sed_args.append(str(random.randint(1, dict_max_words)) + 'p')
		i = i + 1
	sed_cmd = 'sed -n ' + "'" + ';'.join(sed_args) + "'" +  ' ' + word_file
	msg.info(sed_cmd)
	stream = os.popen(sed_cmd)
	words = []
	for line in stream.readlines():
		words.append(line.strip())
	stream.close()
	if ( not args.bare ):
		#
		# Choose an extension
		#
		extension = extn[random.randint(0, len(extn)-1)]
		words.append(extension)
	retval = '.'.join(words)
	return retval
		
# count lines in dict file
def get_total_dict_words():
	cmd = "cat " + word_file + " | wc -l "
	retval = 0
	stream = os.popen(cmd)
	retval = int(stream.readline())
	stream.close()
	return retval

def create_file(args, name):
		size = random.randrange(args.min_size_kb, args.max_size_kb)
		cmd = "cd '" + args.directory + "' && dd if=" + rand_block_dev + " of=" + name + ' iflag=fullblock bs=1k count=' + str(size)
		os.system(cmd)


def main():
	exit_status = 1
	# Check for sanity
	if ( not os.path.isfile(word_file) ):
		msg.err("no dictionary '" + word_file + "'; aborting")
		exit(1)
	else:
		total_words = get_total_dict_words()
		if ( total_words < 50000 ):
			msg.err("Dictionary is suspictious: " + total_words + " < 50000 words")
			exit(1)
		else:
			msg.info("found dict with " + str(total_words) + " words")
	# Parse args
	args = cmdline()
	msg.info('num words = ' + str(args.num_words) )
	random.seed()
	# Do the work
	name = make_file_name(args, total_words)
	if ( 3 < len(name) ):
		if ( args.directory is not None ):
			create_file(args, name)
		exit_status = 0
		print name
	else:
		# Not very helpful, but true (should not happen)
		msg.err("Some problem occured")
	return exit_status

exit(main())


